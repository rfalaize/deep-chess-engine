import time

import flask
from flask_cors import CORS
from flask_restplus import Api, Resource, fields, abort
import engines
import argparse
import threading
import uuid

# configure logger
from logging import getLogger, getLevelName, Formatter, StreamHandler
log = getLogger()
log.setLevel(getLevelName('INFO'))
log_formatter = Formatter("%(asctime)s [%(levelname)s] [%(threadName)s] %(name)s: %(message)s")
console_handler = StreamHandler()
console_handler.setFormatter(log_formatter)
log.addHandler(console_handler)

# create swagger app
app = flask.Flask(__name__)
CORS(app)
api = Api(app,
          version='1.0',
          title='Chess Engine API',
          description='An API to recognize hand written digits.'
)
ns = api.namespace('api/v1/chess', description='Digit recognition operations')

# create API schemas
chessEngineRequest = api.model('ChessEngineRequest', {
    'engine': fields.String(required=True, description='Name of the engine to use'),
    'fen': fields.String(required=True, description='Representation of the chess board in FEN format')
})
chessEngineResponse = api.model('ChessEngineResponse', {
    'success': fields.Boolean,
    'move_id': fields.String(description='Unique ID for the move being calculated. '
                                         'The caller needs to call the /poll URL passing this move_id, '
                                         'to get the results once the move has been generated by the engine.')
})


moves_store = {}


# create routes
@ns.route('/health-check', methods=['GET'])
class HealthCheck(Resource):
    def get(self):
        # return default HTTP code 200
        return


@ns.route('/engine/generate_move', methods=['POST'])
class ChessEngine(Resource):

    @ns.expect(chessEngineRequest)
    @ns.marshal_with(chessEngineResponse, code=201)
    def post(self):
        try:
            req = api.payload
            log.info('New move generation request received: ' + str(req))

            # generate a new move id
            move_id = 'move_id_' + str(len(moves_store)+1) + '_' + str(uuid.uuid1())

            # create a thread
            worker_thread = threading.Thread(target=generate_move, args=(move_id, req['engine'], req['fen']))

            # store thread and id
            moves_store[move_id] = {'worker_thread': worker_thread, 'status': 'WORKING', 'result': ''}

            # start worker
            worker_thread.start()

            result = {'status': True, 'move_id': move_id}
        except Exception as e:
            log.error("Error while generating move:")
            log.exception(e)
            result = {'status': False, 'error': str(e)}
        log.info('>>> result:' + str(result))
        return result, 201


@ns.route('/engine/get_all_moves', methods=['GET'])
class InspectMovesStore(Resource):
    def get(self):
        log.info('Retrieving all moves from moves_store...')
        results = [{
            'move_id': move_id,
            'status': moves_store[move_id]['status'],
            'result': moves_store[move_id]['result'],
            'thread_name': moves_store[move_id]['worker_thread'].getName(),
            'thread_is_alive': moves_store[move_id]['worker_thread'].is_alive()
            } for move_id in moves_store]
        log.info(results)
        return results


@ns.route('/engine/poll_move/<string:move_id>', methods=['GET'])
class PollMove(Resource):
    def get(self, move_id):
        log.info("Polling move_id=" + move_id + "...")
        if move_id not in moves_store:
            abort(400, "move id not found")
        result = {k: moves_store[move_id][k] for k in ('status', 'result')}
        if result['status'] == 'DONE':
            del moves_store[move_id]    # remove from cache once polled
        return result


def generate_move(move_id, engine_name, fen):
    # this function will run on a dedicated thread (one per move)
    # would be better to use a queue with multiple processes (ex: celery or redis),
    # but messaging brokers are only available in Heroku premium

    engine = None
    if engine_name.upper() == 'RANDOM':
        engine = engines.rnd.engine.Engine()
    elif engine_name.upper() == 'MINIMAX.V1':
        engine = engines.minimax.v1.engine.Engine()
    elif engine_name.upper() == 'MINIMAX.V2':
        engine = engines.minimax.v2.engine.Engine()
    elif engine_name.upper() == 'MINIMAX.V3':
        engine = engines.minimax.v3.engine.Engine()
    elif engine_name.upper() == 'MCTS.V1':
        engine = engines.mcts.v1.engine.Engine()

    moves_store[move_id]['result'] = engine.generate_move(fen)
    moves_store[move_id]['status'] = 'DONE'

    log.info('generate_move finished:' + str(moves_store[move_id]['result']))
    return moves_store[move_id]['result']


if __name__ == '__main__':

    log.info("****************************************************************")
    log.info("Starting flask application...")
    log.info("****************************************************************")

    parser = argparse.ArgumentParser()
    parser.add_argument('--env', help='Environment. DEV or PROD', type= str, default='PROD')
    parser.add_argument('--port', help='Port number', type= int, default= 0)
    args = parser.parse_args()
    log.info('Command line arguments: {}'.format(args))

    log.info("Starting application on port {}...".format(args.port))
    app.run(host='0.0.0.0', port=args.port, debug=(args.env == 'DEV'))

